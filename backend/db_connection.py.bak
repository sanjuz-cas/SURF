"""
Simport os
import logging
from typing import List, Dict, Any, Optional
from contextlib import contextmanager
try:
    import psycopg2
    from psycopg2.extras import RealDictCursor
    from psycopg2.pool import SimpleConnectionPool
except ImportError:
    # Fallback for psycopg3
    import psycopg as psycopg2
    from psycopg.rows import dict_row as RealDictCursor
    from psycopg_pool import ConnectionPool as SimpleConnectionPool
from dotenv import load_dotenvomer Feedback Agent - Database Connection Module
==========================================================
Handles PostgreSQL database connections using psycopg2.
"""

import os
import logging
from typing import List, Dict, Any, Optional
from contextlib import contextmanager
import psycopg2
from psycopg2.extras import RealDictCursor
from psycopg2.pool import SimpleConnectionPool
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DatabaseConnection:
    """
    Manages PostgreSQL database connections with connection pooling.
    """
    
    _pool: Optional[SimpleConnectionPool] = None
    
    @classmethod
    def initialize_pool(cls, minconn=1, maxconn=10):
        """Initialize the connection pool."""
        if cls._pool is None:
            try:
                cls._pool = SimpleConnectionPool(
                    minconn,
                    maxconn,
                    host=os.getenv("DB_HOST", "localhost"),
                    port=os.getenv("DB_PORT", "5432"),
                    database=os.getenv("DB_NAME", "surf_feedback_db"),
                    user=os.getenv("DB_USER", "surf_user"),
                    password=os.getenv("DB_PASSWORD", "")
                )
                logger.info("‚úÖ Database connection pool initialized successfully")
            except Exception as e:
                logger.error(f"‚ùå Failed to initialize database pool: {e}")
                raise
    
    @classmethod
    @contextmanager
    def get_connection(cls):
        """
        Context manager for database connections.
        Automatically returns connection to pool after use.
        """
        if cls._pool is None:
            cls.initialize_pool()
        
        conn = cls._pool.getconn()
        try:
            yield conn
            conn.commit()
        except Exception as e:
            conn.rollback()
            logger.error(f"‚ùå Database error: {e}")
            raise
        finally:
            cls._pool.putconn(conn)
    
    @classmethod
    def close_pool(cls):
        """Close all connections in the pool."""
        if cls._pool is not None:
            cls._pool.closeall()
            cls._pool = None
            logger.info("Database connection pool closed")


class FeedbackDatabase:
    """
    High-level database operations for feedback management.
    """
    
    @staticmethod
    def insert_raw_feedback(raw_text: str, source: str, metadata: Optional[Dict] = None) -> int:
        """Insert raw feedback and return the ID."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO raw_feedback (raw_text, source, metadata)
                    VALUES (%s, %s, %s)
                    RETURNING id
                    """,
                    (raw_text, source, psycopg2.extras.Json(metadata or {}))
                )
                feedback_id = cur.fetchone()[0]
                logger.info(f"‚úÖ Inserted feedback ID: {feedback_id}")
                return feedback_id
    
    @staticmethod
    def get_unprocessed_feedback(limit: int = 10) -> List[Dict[str, Any]]:
        """Get unprocessed feedback items."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    """
                    SELECT id, raw_text, source, metadata, created_at
                    FROM raw_feedback
                    WHERE processed = FALSE
                    ORDER BY created_at ASC
                    LIMIT %s
                    """,
                    (limit,)
                )
                results = cur.fetchall()
                logger.info(f"üì• Retrieved {len(results)} unprocessed feedback items")
                return [dict(row) for row in results]
    
    @staticmethod
    def update_feedback_analysis(
        feedback_id: int,
        category: str,
        score: float,
        processed: bool = True
    ) -> None:
        """Update feedback with category and score."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    UPDATE raw_feedback
                    SET category = %s, 
                        severity_volume_score = %s, 
                        processed = %s,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = %s
                    """,
                    (category, score, processed, feedback_id)
                )
                logger.info(f"‚úÖ Updated feedback ID {feedback_id}: {category}, score={score}")
    
    @staticmethod
    def get_top_feedback(limit: int = 3) -> List[Dict[str, Any]]:
        """Get top feedback items by severity_volume_score."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    """
                    SELECT id, raw_text, source, category, 
                           severity_volume_score as score, metadata
                    FROM raw_feedback
                    WHERE processed = TRUE AND severity_volume_score > 0
                    ORDER BY severity_volume_score DESC
                    LIMIT %s
                    """,
                    (limit,)
                )
                results = cur.fetchall()
                logger.info(f"üîù Retrieved top {len(results)} feedback items")
                return [dict(row) for row in results]
    
    @staticmethod
    def insert_prioritized_output(
        feedback_id: int,
        title: str,
        pre_mortem_forecast: str,
        score: float,
        team: str,
        action_plan: Dict[str, Any],
        priority_rank: int
    ) -> int:
        """Insert prioritized output."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO prioritized_output 
                    (feedback_id, title, pre_mortem_forecast, score, team, 
                     action_plan, priority_rank)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    RETURNING id
                    """,
                    (feedback_id, title, pre_mortem_forecast, score, team,
                     psycopg2.extras.Json(action_plan), priority_rank)
                )
                output_id = cur.fetchone()[0]
                logger.info(f"‚úÖ Inserted prioritized output ID: {output_id}")
                return output_id
    
    @staticmethod
    def mark_slack_delivered(output_id: int) -> None:
        """Mark output as delivered to Slack."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    UPDATE prioritized_output
                    SET slack_delivered = TRUE,
                        slack_delivered_at = CURRENT_TIMESTAMP
                    WHERE id = %s
                    """,
                    (output_id,)
                )
                logger.info(f"‚úÖ Marked output ID {output_id} as delivered to Slack")
    
    @staticmethod
    def get_all_raw_feedback() -> List[Dict[str, Any]]:
        """Get all raw feedback for initial ingestion."""
        with DatabaseConnection.get_connection() as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    """
                    SELECT id, raw_text, source, metadata, created_at
                    FROM raw_feedback
                    ORDER BY created_at ASC
                    """
                )
                results = cur.fetchall()
                logger.info(f"üì• Retrieved {len(results)} total feedback items")
                return [dict(row) for row in results]


# Initialize connection pool on module import
try:
    DatabaseConnection.initialize_pool()
except Exception as e:
    logger.warning(f"‚ö†Ô∏è Could not initialize database pool on import: {e}")
